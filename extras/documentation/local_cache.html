<h1>Local caching API</h1>

<p>The oneTRANSPORT SDK provides a way for clients to acquire and store data
from the CSE in a structured format suitable for running local queries.  A
typical Android pattern is implemented where a SQLite database is wrapped by
a Content Provider, using a Sync Adapter to refresh the content when needed.</p>

<p>There is also a class of static helper routines which can return resource
objects if you would prefer not to work with content provider URLs and
database cursors.</p>

<h2>Content helper classes</h2>

<p>Each oneTRANSPORT module contains its own helper class for accessing SQL
tables relating to that module.  The Common module manages a content provider
that allows the other modules to inject tables and to insert, select, update
and delete data.</p>

<p>There's no need to instantiate these classes as they contain only static
methods.  The local authority content helpers are:</p>

<pre><code>    net.uk.onetransport.android.county.bucks.provider.BucksContentHelper.java
    net.uk.onetransport.android.county.herts.provider.HertsContentHelper.java
    net.uk.onetransport.android.county.Northants.provider.NorthantsContentHelper.java
    net.uk.onetransport.android.county.oxon.provider.OxonContentHelper.java
</code></pre>

<p>There are also helper classes for the BitCarrier and Clearview resources
at Silverstone:</p>

<pre><code>    net.uk.onetransport.android.modules.bitcarriersilverstone.provider.BcsContentHelper.java
    net.uk.onetransport.android.modules.clearviewsilverstone.provider.CvsContentHelper.java
</code></pre>

<h2>Refreshing the local cache</h2>

<p>Each content helper provides a <code>refresh</code> method that takes an Android
context and then several boolean parameters which should be true if a
particular resource should be retrieved from the CSE and inserted into the
local database.  For example, here is how to download car parks and roadworks
from Northamptonshire, but not traffic flows, travel times or variable message
signs:</p>

<pre><code>    NorthantsProviderModule.refresh(context, true, true, false, false, false);
</code></pre>

<p>This method forces a sync adapter update of the content provider.  You could
start this in a background thread every few minutes if you wanted to store
frequent updates to CSE resources.  However, note that unless you poll very
often (eg. every minute), it is possible that you may miss some updates.</p>

<p>This is because the refresh process asks the CSE for the latest copy of each
resource and does not go back for all the updates that may have occurred since
the last time you polled the server.  Getting absolutely every change is more
difficult and for that you will need to use Dougal, the oneM2M Android API,
directly.</p>

<p>If you need to know when the update has completed, you can create a content
observer for <code>LastUpdatedProviderModule.LAST_UPDATED_URI</code>.  For example:</p>

<pre><code>    public class AdapterObserver extends ContentObserver {

        private OneTransportTest oneTransportTest;

        public AdapterObserver(Handler handler) {
            super(handler);
        }

        @Override
        public void onChange(boolean selfChange) {
            super.onChange(selfChange);
            // Update has finished.  Do something.
        }

        @Override
        public void onChange(boolean selfChange, Uri uri) {
            super.onChange(selfChange, uri);
            // Update has finished.  Do something.
        }
    }
</code></pre>

<p>This is activated by registering:</p>

<pre><code>    AdapterObserver adapterObserver = new AdapterObserver(null, this);
    context.getContentResolver().registerContentObserver(
        LastUpdatedProviderModule.LAST_UPDATED_URI, true, adapterObserver);
</code></pre>

<p>And when you no longer need to receive notification of an update, you should
deregister the observer:</p>

<pre><code>    context.getContentResolver().unregisterContentObserver(adapterObserver);
</code></pre>

<p>You can of course observe any URI from the content provider, but the point
about <code>LAST_UPDATED_URI</code> is that it will only be refreshed when all of the
downloads in a module have occurred.</p>

<h2>Retrieving resources from the provider</h2>

<p>Each helper has three kinds of getter method.  One takes only a context and
returns a list of objects representing the entire table of resources that
were requested.  For example,</p>

<pre><code>    TrafficQueue[] trafficQueues = OxonContentHelper.getTrafficQueues(context);
</code></pre>

<p>The size of <code>trafficQueues</code> will be the same as the number of rows in the
<code>traffic_queue</code> SQL table.</p>

<p>The second getter method takes a time interval and returns all resources
that were inserted during that time.  So, to retrieve the last 24 hours
of traffic queues around Oxford, we could use:</p>

<pre><code>    long now = System.currentTimeMillis() / 1000L;
    long hours24 = 60L * 60L * 24L;
    TrafficQueue[] trafficQueues = OxonContentHelper.getTrafficQueues(context, now - hours24, now);
</code></pre>

<p>Lastly, it is possible to retrieve only the latest resources from the cache:</p>

<pre><code>    TrafficQueue[] trafficQueues = OxonContentHelper.getLatestTrafficQueues(context);
</code></pre>

<p>In this case, all the resources that were delivered in the latest content
instance will be returned.</p>

<h2>Deleting resources from the cache</h2>

<p>There are a couple of options for removing resources from local storage.
Each module provides methods for deleting all records of a particular type,
or all records of a particular type before a particular time.  The latter
can be useful for pruning back in time when you only want to keep recent
resources.</p>

<p>Removing all traffic queue records:</p>

<pre><code>    OxonContentHelper.deleteFromProvider(context, OxonContentHelper.DATA_TYPE_TRAFFIC_QUEUE);
</code></pre>

<p>Remove traffic queues older than 24 hours:</p>

<pre><code>    OxonContentHelper.deleteFromProviderBeforeTime(context,
                OxonContentHelper.DATA_TYPE_TRAFFIC_QUEUE,
                System.currentTimeMillis() / 1000L - 24L * 60L * 60L);
</code></pre>
